import java.awt.event.KeyEvent;
import java.io.FileReader;
import java.io.IOException;
import java.util.Scanner;

public class World { // Jun Miao
	int width;
	int height;
	FileReader reading;
	Scanner fileScan;
	String Data[];
	public EZImage FWorld[][];
	int ImageSize = 50;
	private boolean done;
	private boolean reachEnd;
	Player turtle;
	private boolean Hit = false;
	private boolean PlayerreachEnd;
	EZImage explosion;
	public EZImage background;
	EZSound GameOver = EZ.addSound("rip.wav");

	World(String file, String world) throws IOException { // constructor
		background = EZ.addImage(world, 512, 384);
		reading = new FileReader(file);
		fileScan = new Scanner(reading);
		width = fileScan.nextInt();
		height = fileScan.nextInt();
		fileScan.nextLine();
		Data = new String[height];
		FWorld = new EZImage[height][width];
		done = false;
		reachEnd = false;
		for (int i = 0; i < height; i++) {
			Data[i] = fileScan.nextLine();
		}
	}

	boolean IsFinishWorldGeneration() { // returns boolean whether or not world is done loading
		return done;
	}

	void generate() throws IOException { // generates the world

		background.translateTo(900, 384);
		for (int a = 0; a < height; a++) {

			for (int b = 0; b < width; b++) {
				char ch = Data[a].charAt(b);
				switch (ch) {
				case 'E':
					FWorld[a][b] = EZ.addImage("End.png", b * ImageSize, a * ImageSize);
				case '?':
					FWorld[a][b] = EZ.addImage("something.png", b * ImageSize, a * ImageSize);
					break;
				case '=':
					FWorld[a][b] = EZ.addImage("brick.jpg", b * ImageSize, a * ImageSize);
					break;
				case 'P':
					turtle = new Player("turtle.png", b * ImageSize, a * ImageSize);
				default:
					// air
					break;
				}
			}
		}
		background.pushToBack();
		done = true;
		Hit = false;
		reachEnd = false;
		PlayerreachEnd = false;
	}

	void move(double Speed) { // moves the whole world
		if (FWorld[height - 1][width - 1].getXCenter() <= 1100) {
			Speed = 0;
			reachEnd = true;
		} else
			for (int h = 0; h < height; h++) {
				for (int w = 0; w < width; w++) {
					if (FWorld[h][w] != null) {
						FWorld[h][w].translateBy(Speed, 0);
						int x = FWorld[h][w].getXCenter();
						if (x < -20) {
							EZ.removeEZElement(FWorld[h][w]);
						}
					}
				}
			}
	}

	void worldGo(int speed) { // start the world game and also moves the player, detects point reached
		if (Hit != true) {
			float vo = 7;
			int x = 0;
			float y = vo;
			if (EZInteraction.isKeyDown(KeyEvent.VK_SPACE)) {
				y = (float) (-vo * 1.4);
			}
			if (turtle.image.getXCenter() < 250 || reachEnd == true) {
				x = speed;
			} else if (turtle.image.getXCenter() >= 250 && reachEnd == false) {
				move(-speed);
				background.translateBy(-0.4, 0);
			}
			if (turtle.image.getYCenter() >= 700) {
				turtle.move(0, -vo);
			}
			turtle.move(x, y);
			if (turtle.image.getYCenter() <= 0) {
				turtle.move(0, -y);
			}
			for (int a = 0; a < height; a++) {

				for (int b = 0; b < width; b++) {
					if (FWorld[a][b] != null) {
						if (turtle.image.isPointInElement(FWorld[a][b].getXCenter(), FWorld[a][b].getYCenter())) {
							Hit = true;
							int iX = FWorld[a][b].getXCenter();
							int iY = FWorld[a][b].getYCenter();
							explosion = EZ.addImage("boom.png", iX, iY);
							GameOver.play();
						}
					}
				}
			}
			if (turtle.image.getXCenter() >= 1030) {
				PlayerreachEnd = true;
			}
		}
	}

	boolean isGameOver() { // return boolean whether or not player is hit
		return Hit;
	}

	boolean reach() { // return boolean whether or not player reached the end
		return PlayerreachEnd;
	}

	void nuke() { // remove everything generated by this file
		for (int a = 0; a < height; a++) {
			for (int b = 0; b < width; b++) {
				if (FWorld[a][b] != null) {
					EZ.removeEZElement(FWorld[a][b]);
				}
			}
		}

		EZ.removeEZElement(background);
		EZ.removeEZElement(explosion);
		turtle.kill();
	}

	void removeScan() throws IOException { //close the scanners
		reading.close();
		fileScan.close();
	}
}
